

// SOL_SOCKET 레벨 옵션은 소켓 코드에서 해석해 처리하므로 프로토콜 독립적인 성격을 띤다
// 하지만 여기에 속한 옵션을 모든 프로토콜에 공통으로 적용할 수 있는 것은 아니므로 주의해야 한다



// SO_BROADCAST 옵션  (UDP 소켓에서만 사용가능)

// SO_BROADCAST 옵션을 설정하면 해당 소켓을 이용해 브로드캐스트 데이터를 보낼 수 있다
// 프로토콜의 특성상 TCP 소켓에는 사용할 수 없고 UDP 소켓에만 사용할 수 있다
// TCP 는 프로토콜 수준에서 SO_BROADCAST 옵션에 대응하는 기능을 제공하지 않기 때문이다

// SO_BROADCAST 옵션은 브로드캐스트 예제를 작성할 때 활용한 경험이 있는데 사용 예를 다시 살펴보면 다음과 같다
/*
	BOOL bEnable = TRUE;
	retval = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char*)&bEnable, sizeof(bEnable));
	if(retval == SOCKET_ERROR) err_quit("setsockopt()");
*/



// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// SO_KEPPALIVE 옵션 (TCP 소켓에서만 사용가능)

// SO_KEEPALIVE 옵션을 설정하면 TCP 프로토콜 수준에서 연결 여부를 확인하려고 상대 TCP에 주기적으로 (약 2시간 간격) TCP 패킷을 보낸다
// 이때 상대 TCP의 반응에 따른 동작은 다음과 같다
/*
	1. 상대가 TCP가 정해진 시간 안에 응답하는 경우
		- TCP 연결에 문제가 없는 상태므로 응용 프로그램은 정상적으로 동작한다

	2. 상대 TCP가 정해진 시간 안에 응답하지 않는 경우
		- TCP 연결에 일시적으로 문제가 있는 상태로 간주할 수 있으므로 몇 번 더 TCP 패킷을 보내보고도 응답이 없으면 자동으로 소켓을 닫아 시스템 자원 소모를 막는다. 
		  나중에 응용 프로그램이 해당 소켓을 사용하려고 하면 오류가 발생한다

	3. 상대 TCP가 RST(reset) 패킷으로 응답하는 경우
		- TCP는 예상치 못한 엉뚱한 패킷이 도달하면 비정상적인 상황으로 간주해 상대편에 RST 패킷을 보냄으로써 연결을 강제 종료한다는 특징이 있다
		  RST 패킷이 도달하면 사실상 연결이 끊어진 것이므로 자동으로 소켓을 닫아 시스템 자원 소모를 막는다
		  나중에 응용 프로그램이 해당 소켓을 사용하려고 하면 오류가 발생한다
*/

// SO_KEEPALIVE 옵션을 사용하는 이유를 생각해보자

// TCP 연결은 단순한 물리적 연결(physical connection)이 아니라, 최초 연결 설정 시 정보를 주고받아 양쪽의 상태 정보를 일치시킨 상태로 통신하는 논리적 연결(logical connection)이다
// 따라서 이후에 데이터 교환이 없다면 상대 호스트가 다운되거나 전원이 끊어진 경우를 감지하지 못한다는 특성이 있다

// 한편, TCP 서버는 접속한 클라이언트 수에 비례하여 소켓을 생성한다, 따라서 이로 인한 시스템 자원 소모도 비례해서 증가하므로 연결이 끊어진 소켓을 그때그때 닫아야 한다
// 그런데 TCP 연결의 특성상 연결이 끊어진 사실을 서버가 감지할 수 없는 경우가 발생한다

// 이때 SO_KEEPALIVE 옵션을 설정해두면 TCP 프로토콜 수준에서 주기적으로 끊어진 연결을 감지해 해당 소켓을 닫으므로 불필요한 시스템 자원 소모를 막을 수 있다

// SO_KEEPALIVE 옵션 사용 예는 다음과 같다
/*
	BOOL bEnable = TRUE;
	retval = setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (char*)&bEnable, sizeof(bEnable));
	if(retval == SOCKET_ERROR) err_quit("setsockopt()");
*/

// SO_KEEPALIVE 옵션은 TCP 소켓에만 사용할 수 있다
// UDP는 프로토콜 수준에서 SO_KEEPALIVE 옵션에 대응하는 기능을 제공하지 않기 때문이다
// TCP 소켓에 사용할 때는 일반적으로 TCP 서버의 연결 대기 소켓에 대해 설정하며, 
// 이 경우 accept() 함수가 리턴하는 소켓도 자동으로 SO_KEEPALIVE 옵션이 설정된 상태로 만들어진다



// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// SO_LINGER 옵션 (TCP 소켓에만 사용할 수 있다)   // 추가 : closesocket() 함수에 대한 추가 설명은 책 268p 를 참고한다

// SO_LINGER 옵션을 설정하면 소켓 송신 버퍼에 미전송 데이터가 있을 때 closesocket() 함수의 리턴 지연 시간을 제어할 수 있다
// 옵션의 필요성을 이해하기 위해 데이터를 보낸 직후에 소켓을 닫는 상황을 생각해보면
/*
	send(sock, ...);	// 데이터를 보낸다
	closesocket(sock);  // 소켓을 닫는다
*/

//TCP 소켓을 사용할 경우, closesocket() 함수는 다음 두 가지 기능을 한다
/*
	1. 소켓을 닫고 할당된 운영체제 자원을 반환한다, 따라서 closesocket() 함수 리턴 후에는 해당 소켓을 통신에 사용할 수 없다
	   이는 TCP 소켓뿐만 아니라 UDP 소켓인 경우에도 마찬가지다

	2. TCP 프로토콜 수준에서 연결 종료 절차를 시작한다.
	   즉, TCP 연결 종료를 위한 최초의 패킷(TCP 기술 문서에서는 FIN 세그먼트(=패킷)라 부름)을 상대편에 보낸다
*/

// 그런데 closesocket() 함수 호출 시점에 send() 함수로 보내려 했던 이전 데이터가 송신 버퍼에 아직 남아 있다면 어떻게 될까?
// 다음 질문에 대한 답을 생각해보자
/*
	1. closesocket() 함수는 언제 리턴하는가?

	2. 송신 버퍼에 남아 있는 데이터를 보낼 것인가, 삭제할 것인가?

	3. TCP 연결을 어떤 방식(정상 종료 혹은 강제 종료)으로 종료할 것인가?
*/

// 위의 질문의 답으로 다양한 동작 방식을 생각해볼 수 있다
/*

	A. closesocket() 함수는 곧바로 리턴하되, 송신 버퍼의 데이터를 백그라운드로 모두 보내고 TCP 연결을 정상 종료한다

	B. closesocket() 함수는 곧바로 리턴하되, 송신 버퍼의 데이터를 삭제하고 TCP 연결을 강제 종료한다

	C. 송신 버퍼의 데이터를 모두 보내고 TCP 연결을 정상 종료한 후 closesocket() 함수가 리턴한다, 
	   만약 일정 시간 안에 송신 버퍼의 데이터를 모두 보내지 못하면 TCP 연결을 강제 종료한 후 closesocket() 함수가 리턴한다
	   이때 송신 버퍼에 남은 데이터는 삭제한다
*/

// SO_LINGER 옵션은 closesocket() 함수의 두 가지 기능을 세부적으로 제어하는 데 사용한다 
// 이를 이용하면 위의 동작 중 한 가지 동작을 구현할 수 있다

// SO_LINGER 옵션 값으로는 linger 구조체를 사용한다
/*
	struct linger{
		u_short l_onoff;  // option on/off  값이 0이면 closesocket() 함수는 곧바로 리턴한다,
							                0이 아니면 l_linger 멤버로 설정한 시간(초 단위) 동안 리턴하지 않고 대기한다

		u_short l_linger; // linger time    closesocket() 함수가 리턴하지 않고 대기할 시간을 초 단위로 지정한다
											0 또는 양수값을 사용한다
	};
	typedef struct linger LINGER;
*/

// SO_LINGER 옵션 사용 예는 다음과 같다
/*
	LINGER optval;

	optval.l_onoff = 1;   // linger on
	optval.l_linger = 10; // linger time = 10초

	retval = setsocketopt(sock, SOL_SOCKET, SO_LINGER, (char*)&optval, sizeof(optval));

	if(retval == SOCKET_ERROR) err_quit("setsocketopt()");
*/

// 옵션 값에 따른 closesocket() 함수 동작을 요약하면 다음과 같다
/*
	SO_LINGER 옵션 값에 따른 closesocket() 함수 동작

	-------------------------------------------------------------------------------------
	I    - linger{} -       closesocket() 함수 동작     추가 설명                        I
	I  l_onoff  l_linger														        I
	I    0     사용안함           A 와 동일            closesocket() 함수의 기본 동작이다 I
	I    1        0              B 와 동일										        I
	I    1     양수              C 와 동일											    I
	-------------------------------------------------------------------------------------
*/

// SO_LINGER 옵션은 TCP 소켓에만 사용할 수 있다, UDP는 프로토콜 수준에서 "정상 종료"와 "강제 종료 개념"을 제공하지 않기 때문이다
// TCP 서버에 SO_LINGER 옵션을 적용할 때는 연결 대기 소켓(listen)에 대해 한 번만 설정해두면, 
// accept() 함수가 리턴하는 소켓도 자동으로 SO_LINGER 옵션이 설정된 상태로 만들어진다
// TPC 클라이언트는 소켓을 보통 한 개만 만들어서 사용하므로 역시 SO_LINGER 옵션을 한 번만 설정하면 된다


// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// SO_SNDBUF, SO_RCVBUF 옵션 (TCP, UDP 모두 사용가능)

// 이 옵션을 이용하면 운영체제가 소켓에 할당하는 송신 버퍼와 수신 버퍼의 크기를 변경할 수 있다
// 두 옵션의 사용법은 같으므로 SO_RCVBUF 옵션의 사용 예만 살펴보자

// 다음 코드는 TCP 서버에서 연결 대기(listening) 소켓의 수신 버퍼 크기를 두 배로 늘리고 있다
// 버퍼 크기를 무한정 늘릴 수 없으므로 제대로 설정됐는지 확인하려고 getsockopt() 함수를 다시 호출한다는 점에 주목하자

/*
	int optval, optlen;

	// 수신 버퍼의 크기를 얻는다
	optlen = sizeof(optval);
	retval = getsockopt(listen_sock, SOL_SOCKET, SO_RCVBUF, (char*)&optval, &optlen);
	if(retval == SOCKET_ERROR) err_quit("getsockopt()");
	printf("수신 버퍼 크기(old) = %d 바이트\n", optval);

	// 수신 버퍼의 크기를 두 배로 늘린다
	optval *= 2;
	retval = setsockopt(listen_sock, SOL_SOCKET, SO_RCVBUF, (char*)&optval, sizeof(optval));
	if(retval == SOCKET_ERROR) err_quit("setsockopt()");

	// 수신 버퍼의 크기를 얻는다
	optlen = sizeof(optval);
	retval = getsockopt(listen_sock, SOL_SOCKET, SO_RCVBUF, (char*)&optval, &optlen);
	if(retval == SOCKET_ERROR) err_quit("getsockopt()");
	printf("수신 버퍼 크기(new) = %d바이트\n", optval);
*/

// 위 코드를 실행한 결과는 수신 버퍼의 기본 크기는 8K바이트 이고, 이 값이 16K바이트로 증가함을 알 수 있다

// SO_SNDBUF와 SO_RCVBUF 옵션 사용 시 권장 사항은, UDP 소켓은 소켓 버퍼 크기를 언제든 변경해도 되지만
// TCP 소켓은 연결이 이루어지기 전에 변경하는 것이다
// 즉, TCP 서버에서는 listen() 함수, TCP 클라이언트에서는 connect() 함수 호출 전에 옵션을 설정하는 것이 좋다
// TCP 서버에 옵션을 적용할 때는 연결 대기 소켓(listening socket)에 대해 한 번만 설정해두면, accept() 함수가 리턴하는 소켓도 자동으로 같은 옵션이 설정된 상태로 만들어진다


// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// SO_SNDTIMEO, SO_RCVTIMEO 옵션 (TCP, UDP 모두 사용가능)

// 전에 언듭했듯이 socket() 함수로 만든 소켓은 블로킹 소켓이므로, 데이터 전송 함수 호출 시 조건이 만족되지 않으면 무한정 블록되어 교착 상태가 발생할 수 있다
// 이때 SO_SNDTIMEO 와 SO_RCVTIMEO 옵션으로 타임아웃을 설정해두면, 데이터 전송 함수(send(), recv(), sendto(), recvfrom() 등)가 적업 완료와 상관없이 일정 시간 후에 리턴하게 할 수 있다
// SO_SNDTIMEO, SO_RCVTIMEO 옵션 값으로는 정수형을 사용하며, 밀리초 단위로 타임아웃을 지정한다

// 두 옵션의 사용법은 동일하므로 SO_RCVTIMEO 옵션 사용 예만 살펴보자
// 다음 코드는 소켓의 수신 타임아웃을 3초로 지정한다

/*
	int optval = 3000;

	retval = setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&optval, sizeof(optval));
	if(retval == SOCKET_ERROR) err_quit("setsocket()");
*/

// 위 코드를 UDP 클라이언트에 추가하고 UDP 서버가 응답하는 코드(sendto() 함수 호출 부분)를 주석 처리한 후 실행하면
// UDP 클라이언트 화면에 오류메시지가 발생한다
// 옵션을 설정하지 않았다면 recvfrom() 함수가 무한정 대기해야 하지만
// 타임아웃을 3초로 지정했으므로 3초 안에 데이터가 도착하지 않으면 recvfrom() 함수가 오류를 리턴한다

// SO_SNDTIMEO 와 SO_RCVTIMEO 옵션은 TCP와 UDP 소켓에 모두 사용할 수 있다
// 이 두 옵션은 교착 상태를 방지하는 목적 외에 통신 상대가 일정 시간 안에 응답하는지 알고 싶을 때도 유용하게 사용할 수 있다(12장 ping 응용프로그램)


// -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// SO_REUSEADDR 옵션 (TCP, UDP 모두 사용가능)

// SO_REUSEADDR 옵션을 설정하면 현재 사용 중인 IP 주소와 포트 번호를 재사용할 수 있다
// 다시 말하면, 현재 사용 중인 IP 주소와 포트 번호를 이용해 bind() 함수를(성공적으로) 호출 할 수 있다

// 이 옵션은 TCP와 UDP 소켓에 모두 사용할 수 있다

/*
	BOOL optval = TRUE;

	retval = setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, (char*)&optval, sizeof(optval));
	if(retval == SOCKET_ERROR) err_quit("setsockopt()");
*/

// bind() 함수 호출부 앞쪽에 SO_REUSEADDR 옵션 설정 코드를 추가한다
// 또한 bind() 함수의 serveraddr.sin_addr.s_addr = inet_addr("127.0.0.1"); 이 부분을 다음과 같이 바꾼다
// IP 주소로 INADDR_ANY 대신 127.0.0.1 을 사용한 이유는 특정 IP 주소와 포트 번호를 중복해서 사용할 수 있는지 확인하기 위함이다

// 실행결과는 같은 서버 두 개(이상) 실행해도 문제가 없으며
// 그 중 하나만 클라이언트 요청에 응답함을 알 수 있다
// 만약 SO_REUSEADDR 옵션을 설정하지 않은 상태로 실행하면, 두 번째 서버를 실행할 때 bind() 함수에서 오류가 발생한다

// SO_REUSEADDR 옵션을 설정하는 목적을 요약하면 다음과 같다
/*
	1. TCP 서버 종료 후 재실행 시 bind() 함수에서 오류가 발생하는 일을 방지한다

		- 유닉스 / 리눅스 운영체제에서 멀티프로세스 기반으로 작성한 TCP 서버를 실행할 때 종종 발생하는 문제다
		  TCP 서버는 새로운 접속이 이루어지면 fork() 함수로 자식 프로세스를 생성해 클라이언트 요청을 처리한다
		  TCP 서버에 문제가 발생해 강제 종료되더라도 자식 프로세스가 남아 포트 번호를 계속 사용하므로 TCP 서버를 재실행할 때 바인딩오류가 발생한다
		  이때 bind() 함수 호출 전에 SO_REUSEADDR 옵션을 설정해두면 오류를 피할 수 있다
		  원도우 운영체제에서는 일반적으로 멀티스레드를 기반으로 작성하므로 TCP서버는 이런 문제가 발생하지 않는다

		  하지만 단일 프로세스로 작성한 TCP 서버를 실행할 때도 종종 바인드 오류가 발생할 수 있다
		  이는 서버의 비정상 종료로 말미암아 지역 주소(=지역IP 주소와 지역 포트 번호)의 TCP 상태가 TIME_WAIT에 머물러 있기 때문이다
		  유닉스 / 리눅스 운영체제에서는 TIME_WAIT 상태에 기인한 바인딩 오류가 흔한 편이지만
		  윈도우 운영체제에서는 상대적으로 경험하기 어렵다
		  당장은 오류가 생기지 않더라도 코드 이식성을 고려해 TCP 서버 작성 시 항상 SO_REUSEADDR 옵션을 설정하는 것이 좋다

	2. 여러 IP 주소를 보유한 호스트에서 같은 기능의 서버를 IP 주소별로 따로 운용할 수 있게 한다

		- 유닉스 / 리눅스 운영체제에서는 서버 실행 시 IP 주소가 달라도 포트 번호만 같으면 바인딩 오류가 발생한다
		  여러 IP 주소를 보유한 호스트에서 같은 기능의 서버를 IP 주소별로 따로 운용하고 싶으면 SO_REUSEADDR 옵션을 설정해둬야 한다
		  윈도우 운영체제에서는 서버 실행 시 포트 번호가 같아도 IP 주소가 다르면 바인딩 오류가 생기지 않는다
		  하지만 코드 이식성을 고려해 서버 작성 시 항상 SO_RESUEADDR 옵션을 설정하는 것이 좋다

	3. 멀티캐스팅 응용 프로그램이 같은 포트 번호를 사용할 수 있게 한다 (UDP 서버에 한정해 활용함)

		- 1. 은 TCP 서버에, 2. 는 TCP 와 UDP 서버 모두에 활용함에 반해 
		  3. 은 UDP 서버에 한정해 활용한다
		  이 부분은 멀티캐스팅 예제를 다룰 때 설명한다
*/
