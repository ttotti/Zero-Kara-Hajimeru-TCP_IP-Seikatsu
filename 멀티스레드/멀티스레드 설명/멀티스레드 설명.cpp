


// 스레드 기초
// 기본으로 작성한 TCP 서버 - 클라이언트 예제는 다음과 같은 문제가 있다

/* 1. 클라이언트 두 개 이상이 서버에 접속할 수는 있으나, 서버가 동시에 클라이언트 두 개 이상에 서비스할 수 없다
	  맨 처음 접속한 클라이언트가 보낸 메시지는 서버 화면에 정상적으로 표시되지만, 두 번째로 접속한 클라이언트가 보낸 메시지는 표시되지 않는다
	  (기본으로 작성한 TCP 서버 - 클라이언트 예제에서 결과를 확인할 수 있다)
	  
	  해결책과 장단점
	  - 서버가 각 클라이언트와 연결해 통신하는 시간을 짧게 줄인다
		예를 들면 <데이터 전송 후 종료> 와 같이 클라이언트가 데이터를 전송하기 전에 매번 서버에 접속하고, 전송 후 곧바로 접속을 끊는 방식을 사용할 수 있다
		
		  - 장점 : 특별한 기법을 도입하지 않고도 쉽게 구현할 수 있다, 서버의 시스템 자원을 적게 사용한다

		  - 단점 : 파일 전송 프로그램과 같이 대용량 데이터를 전송하는 응용 프로그램을 구현하는 데는 적합하지 않다 
				   또한 클라이언트 수가 많을 경우 처리 지연 시간이 길어질 확률이 높다
			   
	  - 서버에 접속한 각 클라이언트를 스레드를 이용해 독립적으로 처리한다
	    
		  - 장점 : 소켓 입출력 모델(바로 아래에 언급)에 비해 비교적 쉽게 구현할 수 있다
		  
		  - 단점 : 접속한 클라이언트 수에 비례해 스레드를 생성하므로 서버의 시스템 자원을 많이 사용한다
		  
	  - 소켓 입출력 모델을 사용한다
	  
		  - 장점 : 소수의 스레드를 이용해 다수의 클라이언트를 처리할 수 있다, 따라서 두 번째 방법보다 서버의 시스템 자원을 적게 사용한다
		  
		  - 단점 : 다른 두 방법보다 구현이 어렵다*/

/* 2. 서버와 클라이언트의 send(), recv() 함수의 호출 순서가 서로 맞아야 한다
	  데이터를 보내지 않은 상태에서 양쪽에서 동시에 recv() 함수를 호출하면 교착 상태가 발생할 수 있다
	  여기서 교착상태(deadlock)란 영원히 일어나지 않을 사건을 두 프로세스가 기다리는 상황을 뜻한다
	  두 프로세스가 recv() 함수에서 빠져나가지 못하고, 이 때문에 send() 함수를 호출할 수 없어 교착 상태가 발생한다
	  
	  ------------            ------------
	  ㅣTCP 서버ㅣ 여기서 대기 ㅣ TCP 클라 ㅣ
	  ㅣ recv() ㅣ <--------> ㅣ  recv() ㅣ
	  ㅣ send() ㅣ  교착 상태  ㅣ  send() ㅣ
	  ㅣ        ㅣ            ㅣ         ㅣ
	  ------------            ------------
	  
	  해결책과 장단점
	  - 데이터 송수신 부분을 잘 설계해 교착 상태가 발생하지 않게 한다
	    
		 - 장점 : 특별한 기법을 도입하지 않고도 구현할 수 있다
		 
		 - 단점 : 데이터 송수신 패턴에 따라 교착 상태가 발생할 수 있다, 따라서 이 방법을 모든 경우에 적용할 수는 없다
		 
      - 소켓에 타임아웃(timeout) 옵션을 적용해, 소켓 함수 호출 시 작업이 완료되지 않아도 일정 시간 후에 리턴하게 한다
	  
	     - 장점 : 비교적 간단하게 구현할 수 있다
		 
		 - 단점 : 다른 방법보다 성능이 떨어진다
		 
	  - 넌블로킹 소켓을 사용한다
	    
		 - 장점 : 교착 상태를 막을 수 있다
		 
		 - 단점 : 구현이 복잡하다, 시스템 자원(특히 CPU 시간)을 불필요하게 낭비할 가능성이 크다
		 
	  - 소켓 입출력 모델을 사용한다
	  
	     - 장점 : 넌블로킹 소켓의 단점을 보완함과 더불어 교착 상태를 막을 수 있다
		 
		 - 단점 : 첫 번째나 두 번째 방법보다 구현이 어렵다, 그러나 세 번째 방법보다는 쉽고 일관성있게 구현할 수 있다*/

// ------------------------------------------------------------------------------------------------------------------------------------------

// 스레드 기본 개념

/* 프로세스 개념
   원도우 운영체제를 제외한 대부분의 운영체제에서 프로세스는 CPU 시간을 할당받아 실행 중인 프로그램을 일컫는다
   프로그램이 저장 장치에 파일로 존재하는 정적인 개념인 데 반해, 
   프로세스는 코드(CPU 명령), 데이터(전역 변수, 정적 변수), 리소스(그림 파일, 사운드 파일 등)를 파일에서 읽어들여 작업을 수행하는 동적인 개념이다
   
   반면 윈도우 운영체제에서는 일반적인 의미의 프로세스 개념을 프로세스와 스레드 두 개로 구분하고 있다
   - 프로세스(process)는 코드, 데이터, 리소스를 파일에서 읽어들여 윈도우 운영체제가 할당해놓은 메모리 영역에 담고 있는 일종의 컨테이너로, 정적인 개념이다
   - 스레드(therad)는 CPU 시간을 할당받아 프로세스 메모리 영역에 있는 코드를 수행하고 데이터를 사용하는 동적인 개념이다
   요약하면, 일반 운영체제의 프로세스 = 원도우 운영체제의 프로세스 + 스레드 라고 보면 된다
   
   윈도우 응용 프로그램이 CPU 시간을 할당받아 실행하려면 "스레드가 최소 하나 이상" 필요하다
   응용 프로그램 실행 시 최초로 생성되는 스레드를 "주 스레드" 또는 "메인 스레드" 라 부르는데, WinMain() 또는 main() 함수에서 실행을 시작한다
   스레드를 추가로 생성해 이 스레드가 해당 작업을 수행하게 하면 된다, 많은 윈도우 응용 프로그램이 이렇게 구현되어 있는데 이를 "멀티스레드 응용 프로그램" 이라 한다
   
   멀티스레드를 활용하면 사용자는 응용 프로그램 하나가 동시에 여러 작업을 수행하는 것처럼 느끼게 된다
   물리적인 CPU 개수는 하나뿐이고 스레드는 두 개라고 가정하면 CPU 하나가 스레드 두 개를 동시에 실행할 수는 없다
   하지만 교대로 실행하는 일은 가능하다 교대로 실행하는 간격이 충분히 짧다면 사용자는 두 스레드가 동시에 실행되는 것처럼 느낀다

   이렇게 하려면 각 스레드의 최종 실행 상태를 저장하고 나중에 복원하는 작업을 반복해야 한다
   스레드의 실행 상태란 CPU와 메모리 상태를 말하며, 구체적으로는 CPU 레지스터 값과 메모리의 스택을 의미한다
   하드웨어(CPU)와 소프트웨어(운영체제)의 협동으로 이루어지는 스레드 실행 상태의 저장과 복원 작업을 "컨텍스트 전환" 이라 일컬으며
   이 덕분에 각 스레드는 다른 스레드의 존재와 무관하게 상태를 유지하면서 실행할 수 있다
   
   프로세스 하나가 스레드 두 개를 단계별로 사용하는 원리
   
     - (a) : 스레드(1)이 실행 중이다, 명령을 하나씩 수행할 때마다 CPU 레지스터 값과 메모리의 스택 내용이 변경된다 
	        (스레드(1) 실행)
	 
	 - (b) : 스레드(1)의 실행을 중지하고 실행 상태를 저장한다(스택은 메모리에 계속 유지된다) 이전에 저장해둔 스레드(2)의 상태를 복원한다 
	        (컨택스트 전환 (1) -> (2))
	 
	 - (c) : 스레드(2)를 실행한다, 명령을 하나씩 수행할 때마다 CPU 레지스터 값과 메모리의 스택 내용이 변경된다 
	        (스레드(2) 실행)

	 - (d) : 스레드(2)의 실행을 중지하고 실행 상태를 저장한다, 이전에 저장해둔 스레드(1)의 상태를 복원한다 
	        (컨택스트 전환(2) -> (1))
	 
	 - (e) : 스레드(1)을 다시 실행한다, 이전 실행 상태를 복원했으므로 스레드(1)은 마지막으로 수행한 명령 다음 위치부터 진행한다 
	        (스레드(1) 실행)*/

// ------------------------------------------------------------------------------------------------------------------------------------------

// 스레드 생성과 종료

/* 프로세스가 생성되면 main() 함수를 실행 시작점으로 하는 주 스레드가 자동으로 생성된다
   이때 또 다른 함수인 f()를 실행 시작점으로 하는 스레드를 생성하려면 다음과 같은 정보를 운영체제에 제공해야 한다 
   
   1. f() 함수의 시작 주소
      - 운영체제는 f() 함수의 시작 주소를 알아야 한다, C/C++ 프로그램에서는 함수 이름이 곧 그 함수의 시작 주소를 의미한다
	    f() 함수와 같이 스레드 실행 시작점이 되는 함수를 "스레드 함수" 라 부른다
		
   2. f() 함수 실행 시 사용할 스택의 크기
      - C/C++ 프로그램의 모든 함수는 실행 중 인자 전달과 변수 할당을 위해 스택이 필요하다,
	    만약 f() 함수를 실행 시작점으로 하는 스레드 두 개를 생성하고자 한다면, 서로 다른 메모리 위치에 스택 두 개를 할당해야 한다
		스레드 실행에 필요한 스택 생성은 운영체제가 자동으로 해주므로 응용 프로그램은 스택 크기만 알려주면 된다
   
   CreateThread() 함수는 스레드를 생성한 후 스레드 핸들을 리턴한다,
   스레드 핸들은 파일 디스크립터나 소켓 디스크립터와 비슷한 개념으로, 운영체제의 스레드 관련 데이터 구조체를 간접적으로 참조하는 매개체 역할을 한다
   응용 프로그램은 스레드 핸들을 윈도우 API 함수에 전달함으로써 다양한 방식으로 스레드를 제어할 수 있다

   윈도우에서 스레드를 생성할 때는 CreateThread() API 함수를 사용한다
   
   HANDLE CreateThread(
	 LPSECURITY_ATTRIBUTES lpThreadAttributes, 
	 // SECURITY_ATTRIBUTES 구조체를 통해 핸들 상속과 보안 디스크립터 정보를 전달한다
	    상세 내용은 현제 공부하는 범위를 넘어서므로 설명을 생략하지만 NULL 값을 사용하면 스레드를 생성하고 활용하는데 전혀 문제가 없다

	 SIZE_T dwStackSize,
	 // 스레드에 할당되는 스택 크기(바이트 단위)다
	    0을 사용하면 실행 파일의 헤더에 들어 있는 기본 크기를 사용하는데, 비주얼 C++로 응용 프로그램을 만든 경우 기본 크기는 1MB 다

	 LPTHREAD_START_ROUTINE lpStartAddress,
	 // 스레드 함수의 시작 주소다, 스레드 함수는 반드시 다음과 같은 형태로 정의해야 한다
	    DWORD WINAPI ThreadProc(LPVOID lpParameter)
		{

		}

	 LPVOID lpParameter,
	 // 스레드 함수에 전달할 인자다, void형 포인터므로 포인터 크기보다 같거나 작은 데이터는 값 또는 주소 형태로 전달하면 된다
	    프인터 크기보다 큰 데이터는 값을 구조체나 배열에 넣고 주소 형태로 전달하면 된다, 전달할 인자가 없으면 NULL 값을 사용하면 된다

	 DWORD dwCreationFlags,
	 // 스레드 생성을 제어하는 값으로 0 또는 CREATE_SUSPENDED를 사용한다, 0을 사용하면 스레드는 생성 후 곧바로 실행되고,
	    CREATE_SUSPENDED를 사용하면 스레드가 생성은 되지만 ResumeThread() 함수를 호출하기 전까지 실행되지 않는다

	 LPDWORD lpThreadId
	 // DWORD형 변수를 전달하면 여기에 스레드 ID가 저장된다,
	    스레드 ID가 필요없으면 윈도우 NT 계열에서는 NULL 값을 사용해도 된다
   );   - 성공 : 스레드 핸들,  실패 : NULL -
   
 // ------------------------------------------------------------------------------------------------------------------------------------------
   
   윈도우에서 스레드를 종료하는 방법에는 다음 네 가지가 있다

   1. 스레드 함수가 리턴한다 
     (스레드를 종료하는 데 바람직하다)

   2. 스레드 함수 안에서 ExitThread() 함수를 호출한다 
     (스레드를 종료하는 데 바람직하다)

	 void ExitThread(
	   DWORD dwExitCode // 종료 코드
	 );

   3. 다른 스레드가 TerminateThread() 함수를 호출해 스레드를 강제 종료시킨다  
     (꼭 필요한 경우에만 사용해야 한다)

	 BOOL TreminateThread(
	   HANDLE hThread,  // 종료할 스레드를 가리키는 핸들
	   DWORD dwExitCode // 종료 코드
	 );   - 성공 : 0이 아닌 값,  실패 : 0 -

   4. 주 스레드가 종료하면 모든 스레드가 종료된다 
     (정상적인 방법이라기보다는 주 스레드(즉, 메인 함수)의 특성으로 이해하면 된다)

   
   */