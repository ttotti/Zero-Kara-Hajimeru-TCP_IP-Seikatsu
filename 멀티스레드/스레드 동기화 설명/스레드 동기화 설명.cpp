

// 멀티스레드를 이용하는 프로그램에서 스레드 두 개 이상이 공유 데이터에 접근하면 다양한 문제가 발생할 수 있다

// 예를 들면
/*
	int money = 1000 // 공유 변수

	(스레드 1)
	1. read money into ECX
	2. ECX = ECX + 2000
	3. write ECX into money

	(스레드 2)
	1. read money into ECX
	2. ECX = ECX + 4000
	3. write ECX into money

	만약 (스레드 1)이 1번을 수행한 상태에서 정지되고
	(스레드 2)가 1 ~ 3번을 수행하면, money 값은 5000(1000 + 4000) 이 된다.
	다시 (스레드 1)이 CPU 시간을 할당받아 2 ~ 3번을 수행하면,
	ECX에 저장되어 있던 값(1000)에 2000이 더해지고 이 값이 메모리에 저장되어 있는 money 값은 3000이 된다
	결과적으로 (스레드 2)가 더한 값인 4000은 사리지는 셈이다

	// 이는 CPU 레지스터 값이 스레드마다 별도로 유지된다는 점에 유의하여 이해해야 한다
*/

// 이처럼 멀티스레드 환경에서 발생하는 문제를 해결하기 위한 일련의 작업을 "스레드 동기화" 라 한다
// 윈도우 운영체제는 프로그래머가 상황에 따라 적절한 동기화 기법을 선택할 수 있도록 다양한 API 함수를 제공한다

/*
	스레드 동기화 기법  (자세한건 인터넷, 관련서적을 참고한다)

	임계 영역(critical section) 
	- 공유 자원에 대해 오직 한 스레드의 접근만 허용한다 (한 프로세스에 속한 스레드 간에만 사용 가능)

	뮤텍스(mutex)
	- 공유 자원에 대해 오직 한 스레드의 접근만 허용한다 (서로 다른 프로세스에 속한 스레드 간에도 사용 가능)

	이벤트(event)
	- 사건 발생을 알려 대기 중인 스레드를 깨운다

	세마포어(semaphore)
	- 한정된 개수의 자원에 여러 스레드가 접근 할 때, 자원을 사용할 수 있는 스레드 개수를 제한한다

	대기 가능 타이머(waitable timer)
	- 정해진 시간이 되면 대기 중인 스레드를 깨운다
*/

// 스레드 동기화 기본 개념

// 스레드 동기화가 필요한 상황은 크게 다음 두 경우다
// 1. 둘 이상의 스레드가 공유 자원에 접근한다
// 2. 한 스레드가 작업을 완료한 후, 기다리고 있는 다른 스레드에 알려준다

// 두 경우 모두 각 스레드가 독립적으로 실행하지 않고 다른 스레드와의 상호 작용을 토대로 자신의 작업을 진행한다는 특징이다
// 스레드 동기화를 하려면 스레드가 상호 작용해야 하므로 "중간 매개체"가 필요하다
// 두 스레드가 동시에 진행하면 안 되는 상황이 있을 때, 두 스레드는 매개체를 통해 진행 가능 여부를 판단하고 이에 근거해 자신의 실행을 계속할지를 결정한다
/*
	스레드1 -> 매개체 <- 스레드2
	  l                 (대기)
	  V
	(진행)
*/

// 윈도우 운영체제에서 이러한 매개체 역할을 할 수 있는 것을 통틀어 "동기화 객체" 라 한다
// 동기화 객체의 특징
/*
	1. Create*() 함수를 호출하면 커널(kernel : 운영체제의 핵심 부분을 뜻함) 메모리 영역에 동기화 객체가 생성되고,
	   이에 접근할 수 있는 핸들(HANDLE 타입)이 리턴된다

	2. 평소에는 "비신호 상태" 로 있다가 특정 조건이 만족되면 "신호 상태" 가 된다,
	   비신호 상태에서 신호 상태로 변화 여부는 Wait*() 함수를 사용해 감지할 수 있다

	3. 사용이 끝나면 CloseHandle() 함수를 호출한다
*/

// Wait*() 함수는 스레드 동기화를 위한 필수 함수로, 자주 사용하는 WaitForSingleObject() 와 WaitForMultipleObjects() 함수가 있다
// 동기화 객체를 학습할 때는 비신호 -> 신호, 신호 -> 비신호 상태 변화 조건을 잘 이해해야 하며,
// 상황에 맞게 Wait*() 함수를 사용할 수 있도록 연습해야 한다