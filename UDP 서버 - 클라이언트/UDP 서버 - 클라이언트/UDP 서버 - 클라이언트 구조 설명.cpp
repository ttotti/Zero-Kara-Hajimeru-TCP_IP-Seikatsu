

// UDP 서버 - 클라이언트 구조 설명

// UDP 프로토콜 개요

// TCP와 UDP는 전송 계층 프로토콜이라는 점에서 다음과 같은 공통점이 있다
/*
	 1. 포트 번호를 이용해 주소를 지정한다
		- 두 응용 프로그램이 TCP나 UDP를 이용해 통신하려면 반드시 포트 번호를 결정해야 한다

	 2. 데이터 오류를 체크한다
		- TCP와 UDP는 IP 패킷 전송 기능을 기반으로 동작한다.
		  전송 중 여러 원인으로 오류가 발생할 수 있는데, IP는 프로토콜 동작에 필수적인 IP 헤더에 대해서만 오류를 체크하고
		  데이터는 체크하지 않는다, 반면 TCP와 UDP는 헤더는 물론이고 데이터에 대한 오류도 체크한다
*/

// TCP와 UDP는 다음과 같은 차이점이 있다
/*
	---------------------------------------------------------
	-        TCP				         UDP                -  
	-   연결형 프로토콜             비연결형 프로토콜         -
	-												        -
	-   신뢰성 있는 데이터 전송     신뢰성 없는 데이터 전송    -
	-   - 데이터를 재전송함         - 데이터를 재전송하지 않음 -
	-													    -
	-   일대일 통신                 일대일 통신, 일대다 통신  -
	-													    -			
	-   데이터 경계 구분 안함        데이터 경계 구분함       -
	-   - 바이트 스트림             - 데이터 그램 서비스      -
	---------------------------------------------------------
*/

// UDP의 항목별 특징을 소켓 함수 관점에서 정리하면 다음과 같다
/*
	1. 연결 설정을 하지 않으므로 connect() 함수를 사용하지 않는다

	2. 프로토콜 수준에서 신뢰성 있는 데이터 전송을 보장하지 않으므로, 
	   필요하다면 응용 프로그램 수준에서 신뢰성 있는 데이터 전송 기능을 구현해야 한다

	3. 간단한 소켓 함수 호출 절차만 따르면 다자 간 통신을 쉽게 구현할 수 있다

	4. TCP와 달리 응용 프로그램이 데이터 경계 구분을 위한 작업을 별도로 할 필요가 없다
*/

// UDP 서버 - 클라이언트 동작 원리
// UDP 서버는 TCP 서버와 달리 멀티스레드 등의 프로그래밍 기법을 사용하지 않고도 한 소켓으로 여러 클라이언트를 처리할 수 있다
/*
	1. 서버는 소켓을 생성하고 클라이언트가 데이터를 보내기를 기다린다.
	   이때 서버가 사용하는 소켓은 특정 포트 번호(예를 들면 9000번)와 결합되어 있어서 이 포트 번호로 도착한 데이터만 수신할 수 있다

	2. 첫 번째 클라이언트는 연결 설정 없이 서버와 데이터를 곧바로 주고받는다

	3. 두 번째 클라이언트도 연결 설정 없이 서버와 데이터를 곧바로 주고받는다,
	   TCP 서버와 달리 UDP 서버는 소켓을 한 개만 사용한다는 점에 주목하자

	4. UDP 서버 - 클라이언트가 통신하는 일반적인 상황이다,
	   'UDP 클라이언트 #n' 처럼 한 클라이언트가 소켓을 두 개 이상 사용해 서버와 통신할 수도 있다
*/

// UDP 서버 - 클라이언트 실습
/*
	UDP 서버 : 클라이언트가 보낸 데이터를 받고(recvfrom),
			   이를 문자열로 간주해 무조건 화면에 출력한다(printf),
			   그리고 받은 데이터를 변경 없이 다시 클라이언트에 보낸다(sendto),
			   받은 데이터를 그대로 다시 보낸다는 뜻으로 '에코 서버' 라 부른다

	UDP 클라이언트: 사용자가 키보드로 입력한(fgets) 문자열을 서버에 보낸다(sendto),
				    서버가 데이터를 그대로 돌려보내면, 클라이언트는 이를 받아(recvfrom)
					화면에 출력한다(printf),
					'에코 서버'와 통신한다는 의미로 '에코 클라이언트' 라 부른다
*/

// -------------------------------------------------------------------------------------------------------------------------

// UDP 서버 - 클라이언트 분석

// UDP 소켓과 연관된 운영체제의 구조체에는 TCP 소켓과 비교해보면 송신 버퍼가 없다는 사실을 알 수 있다
// UDP는 TCP와 달리 데이터 재전송과 흐름제어를 하지 않으므로 TCP와 같은 개념의 송신 버퍼(데이터 재전송용)는 존재하지 않는다

// 응용 프로그램에서 통신을 수행하려면 다음과 같은 요소를 결정해야 한다
// TCP/IP와 연관지어 설명한 내용과 같음을 알 수 있다
/*
	프로토콜 : 통신 규약으로, 소켓을 생성할 때 결정한다

	지역(local)IP 주소와 지역 포트 번호 : 서버 또는 클라이언트 자신의 주소다

	원격(remote) IP 주소와 원격 포트 번호 : 서버 또는 클라이언트가 통신하는 상대의 주소다
*/

// UDP 소켓 데이터 구조체
/*
		   ----------------                      ---------------- 
		   l     서버      l  <--  네트워크 -->  l  클라이언트   l   <----- 응용 프로그램
		   ----------------                      ----------------
		   l 지역 IP 주소  l                     l 지역 IP 주소  l   <-----
		   ----------------                      ----------------        ㅣ
		   l 지역 포트 번호 l                    l 지역 포트 번호 l        ㅣ
		   ----------------                      ----------------        ㅣ
		   l 원격 IP 주소  l                     l 원격 IP 주소  l        ㅣ
		   ----------------                      ----------------        ㅣ 운영 체제
		   l 원격 포트 번호 l                    l 원격 포트 번호 l        ㅣ
		   ----------------                      ----------------        ㅣ 
		   l   수신 버퍼   l                     l   수신 버퍼   l        ㅣ
		   ----------------                      ----------------		 ㅣ
		   l      ...      l                    l      ...      l   <-----
		   ----------------                      ---------------- 
		   
*/

// UDP 서버 - 클라이언트 모델

/*
	UDP 서버

	1. socket() 함수로 소켓을 생성함으로써 사용할 프로토콜을 결정한다

	2. bind() 함수로 지역 IP 주소와 지역 포트 번호를 결정한다

	3. 클라이언트가 보낸 데이터를 recvfrom() 함수로 받는다.
	   이때 원격 IP 주소와 원격 포트 번호, 즉 클라이언트의 주소를 알 수 있다

    4. 받은 데이터를 처리한 결과를 sendto() 함수로 보낸다

	5. 모든 작업을 마치면 closesocket() 함수로 소켓을 닫는다

	------------------------------------------------------------------------------------

	UDP 클라이언트

	1. socket() 소켓을 생성함으로써 사용할 프로토콜을 결정한다

	2. sendto() 함수로 서버에 데이터를 보낸다,
	   이때 원격 IP 주소와 원격 포트 번호는 물론, 지역 IP 주소와 지역 포트 번호도 결정된다

	3. 서버가 처리해 보낸 데이터를 recvfrom() 함수로 받는다

	4. 모든 작업을 마치면 closesocket() 함수로 소켓을 닫는다
*/

// UDP 서버                      ------------------------------
//                               V                            I                         
// socket() -------> bind() -------> recvfrom() --> sendto() --> closesocket()
//                                       ^             I
//						                 I             V
//                                l-------------------------l
//                                l        네트워크          l
//                                l-------------------------l
//                                       ^             I
//                                       I             V
// socket() -----------------------> sendto() --> recvfrom() --> closesocket()
//                               ^                            I
// UDP 클라이언트                ------------------------------

// UDP 서버 - 클라이언트 모델을 사용할 때 주의할 점은 다음과 같다
/*
	1. 블로킹 소켓을 사용할 경우, 송수신 함수의 호출 순서가 맞지 않으면 교착 상태가 발생할 수 있다

	2. 클라이언트는 데이터를 받은 후 송신자의 주소(IP 주소, 포트 번호)를 확인해야 한다
	   recvfrom() 함수는 UDP 서버가 보낸 데이터는 물론, 전혀 다른 UDP 응용 프로그램이 보낸 데이터도 수신할 수 있기 때문이다
*/

// UDP 클라이언트를 다음과 같이 작성할 수도 있다
// UDP 소켓에 대해 connect() 함수를 호출하면 통신할 상대의 주소 정보가 내부적으로 기억되므로,
// sendto() / recvfrom() 함수 대신 send() / recv() 함수를 사용해 특정 UDP 서버와 통신할 수 있다

// UDP 서버                      ------------------------------
//                               V                            I                         
// socket() -------> bind() -------> recvfrom() --> sendto() --> closesocket()
//                                       ^             I
//						                 I             V
//                                l-------------------------l
//                                l        네트워크          l
//                                l-------------------------l
//                                       ^             I
//                                       I             V
// socket() ------connect()----------> send() -----> recv() --> closesocket()
//                               ^                            I
// UDP 클라이언트                ------------------------------

// 위와 같이 나타낸 UDP 서버 - 클라이언트 모델의 장점은 다음과 같다
/*
	1. sendto() 함수를 사용한 경우보다 효율적이다, 
	   connect() 함수로 서버 주소를 한 번만 설정해두면 send() 함수가 이 정보를 재사용하기 때문이다

	2. 데이터를 받은 후 송신자의 주소(IP 주소, 포트 번호)를 확인하지 않아도 된다.
	   recvfrom() 함수와 달리 recv() 함수는 connect() 함수로 설정한 대상을 제외한 다른 UDP 응용 프로그램이 보낸 데이터는 수신하지 않기 때문이다

	// 그러나 이 모델 역시 다음 사항에 주의해야 한다
	   - 블로킹 소켓을 사용할 경우, 송수신 함수의 호출 순서가 맞지 않으면 교착 상태가 발생할 수 있다
*/