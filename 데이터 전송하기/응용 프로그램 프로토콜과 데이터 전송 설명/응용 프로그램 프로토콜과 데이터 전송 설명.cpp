


// TCP 서버 - 클라이언트의 기본 구조는 정해져 있어서 각 함수의 의미를 이해하고 나면 뼈대가 되는 코드를 그대로 복사해 재사용할 수 있다

// 그렇다면 응용 프로그램의 고유 기능을 결정하는 부분은 어디일까, 바로 데이터 처리 부분이다
// 어떤 데이터를 어떤 형식으로 주고받고 어떻게 처리할지를 결정하는 일은 네트워크 응용 프로그램 개발자가 해야 할 가장 중요한 작업이다

// 응용 프로그램 프로토콜 : 응용 프로그램 수준에서 주고받는 데이터의 형식과 의미 그리고 처리 방식을 정의한 프로토콜이다
// TCP나 IP와 같은 표준 통신 프로토콜에서 주고받는 패킷의 형식과 의미 그리고 처리 방식을 정의한 것과 비슷하나,
// 응용 프로그램마다 자유롭게 정의한다는 점, 즉 표준화되어 있지 않다는 점이 다르다
// 응용 프로그램 프로토콜이 결정되면 데이터를 정해진 형식과 절차에 따라 주고받아 처리하도록 소켓 함수를 이용해 구현하면 된다

// 응용 프로그램 프로토콜의 기본은 주고받을 메시지 형식을 정하는 것이다

// 예를 들면
// 네트워크를 통해 자신과 상대방의 화면에 동시에 그림을 그리는 네트워크 그림판 프로그램을 만든다 하면
// 두 프로그램이 주고받아야 할 정보는 다음과 같다
// 1. 직선의 시작과 끝점
// 2. 선의 두께와 색상

// 주고 받을 데이터를 구조체로 표현하면 다음과 같다
/*struct DrawingMessage1
{
	int x1, y1; // 직선의 시작점
	int x2, y2; // 직선의 끝점
	int width;  // 선의 두께
	int color;  // 선의 색상
}*/

// 이 프로그램에 원 그리기 기능을 추가한다면 다음 정보도 주고 받아야 한다
// 1. 원의 중심 좌표
// 2. 원의 반지름
// 3. 내부 채우기 색상
// 4. 테두리 두께와 색상

// 원을 그리기 위해 주고받을 데이터를 구조체로 표현하면 다음과 같다
/*struct DrawingMessage2
{
	int x, y;      // 원의 중심 좌표
	int r;		   // 원의 반지름
	int fillcolor; // 내부 채우기 색상
	int width;     // 테두리 두께
	int color;     // 테두리 색상
}*/

// 이와 같이 두 개의 메시지 형식을 정의하면 네트워크를 통해 데이터를 받은 쪽에서는 어떤 타입(직선 또는 원)인지 구분할 수 없으므로 다음과 같이 타입을 나타내는 필드를 추가해야 한다
/*struct DrawingMessage1
{
	int type;   // = LINE

	int x1, y1; // 직선의 시작점
	int x2, y2; // 직선의 끝점
	int width;  // 선의 두께
	int color;  // 선의 색상
}*/

/*struct DrawingMessage2
{
	int type	   // = CIRCLE

	int x, y;      // 원의 중심 좌표
	int r;		   // 원의 반지름
	int fillcolor; // 내부 채우기 색상
	int width;     // 테두리 두께
	int color;     // 테두리 색상
}*/
// 이렇게 맨 앞부분의 32비트(int type)를 읽으면 직선 데이터인지 원 데이터인지 알 수 있으므로 나머지 부분을 읽어서 올바로 처리할 수 있다


// 데이터 전송
// 통신 양단이 주고받을 데이터를 구조체로 정의하는 것만으로는 아직 충분하지 않다

// 데이터를 전송할 때 고려할 사항

// 경계 구분
// TCP 처럼 메시지 경계를 구분하지 않는 프로토콜을 사용할 경우에는 응용 프로그램 수준에서 메시지 경계를 구분하기 위한 추가 작업을 해야 한다

// 다음과 같이 네 가지 방법을 고려할 수 있다  (송신자 : 보내는 측, 수신자 : 받는 측)

/* 1. 송신자는 항상 고정 길이 데이터를 보낸다, 수신자는 항상 고정 길이 데이터를 읽는다

	  - 구현이 쉽지만 미래에 사용할 가장 긴 데이터를 감안해 고정 길이를 정해야 한다는 문제가 있고
	    길이가 짧은 데이터를 주고받을 때 낭비하는 부분이 생긴다, 하지만 주고받을 데이터의 길이 변동폭이 크지 않을 경우에는 편리하다

   2. 송신자는 가변 길이 데이터를 보내고 끝 부분에 특별한 표시(EOR, End Of Record)를 붙인다, 수신자는 EOR이 나올 때까지 데이터를 읽는다

      - 생성될 데이터의 길이를 미리 알 수 없을 때 사용하기 적합하다
		데이터가 생성되면 곧바로 전송하되 끝이라고 판단하면 EOR을 전송한다, 하지만 몇 가지 문제점이 있으므로 유의해야 한다
		첫째, 데이터 중간에 EOR과 똑같은 패턴이 들어 있으면 안 된다.
		둘째, 데이터를 효율적으로 수신하는 방식을 고안하지 않으면 성능이 떨어질 수 있다
			  단순히 한 바이트씩 읽어서 EOR을 검출하는 방법을 사용하면 동작은 하지만 수신자의 데이터 처리 속도가 지나치게 느려진다

   3. 송신자는 보낼 데이터 크기를 고정 길이 데이터로 보내고, 이어서 가변 길이 데이터를 보낸다
	  수신자는 고정 길이 데이터를 읽어서 뒤따라올 가변 데이터의 길이를 알아내고, 이 길이만큼 데이터를 읽는다

	  - 구현도 쉽고 처리 효율성도 높다
		3번을 적용할 경우의 메시지 구조를 보여준다, 이때는 recvn() 함수 호출 두 번으로 데이터를 모두 읽을 수 있다 (recvn()는 recv()의 사용자 정의 함수이다)

	  - 메시지 구조 -

	  ------헤더-------
	  ㅣ (고정 길이)  ㅣ
	  V               V
	  --------------------------------------------------
	  ㅣ  부가 정보   ㅣ            데이터              ㅣ
	  ㅣ    ...      ㅣ          (가변 길이)            ㅣ
	  ㅣ 데이터 길이  ㅣ                                ㅣ
	  --------------------------------------------------

   4. 송신자는 가변 길이 데이터 전송 후 접속을 정상 종료한다, 수신자는 recv() 함수의 리턴 값이 0(= 정상 종료)이 될 때까지 데이터를 읽는다 
      - 한쪽에서 다른 쪽으로 일방적으로 데이터를 보내는 경우에 적당하다
		하지만 데이터를 자주 전송하는 경우에는 [TCP 연결 설정 / 데이터 전송 / TCP 연결 종료]를 반복해야 하므로 비효율적이다*/

// 바이트 정렬
// 서로 다른 바이트 정렬 방식을 사용하는 시스템 사이에 데이터를 교환할 때는 바이트 정렬 방식을 통일해야 한다
// 그렇지 않으면 데이터 해석에 문제가 생긴다, 특별한 전제가 없으면 빅 엔디안 방식으로 통일하는 것이 좋다 (바이트 정렬 변환 함수를 사용)

// 구조체 멤버 맞춤
// 구조체(C++의 클래스도 포함) 멤버의 메모리 시작 주소를 결정하는 컴파일러의 규칙이다
// 간단한 예를 들어보면 다음과 같이 구조체를 이용해 메시지를 정의하면 10(= 4 + 1 + 4 + 1)바이트가 아닌 16바이트가 전송된다
/*struct MyMessage
{
	int a;  // 4바이트
	int b;  // 1바이트
	int c;	// 4바이트
	char d;	// 1바이트
}

MyMessage msg;
...
send(sock, (char*)&msg, sizeof(msg), 0);*/

// 변수 msg의 메모리 구조이다 (기본값)
// 기본적으로 C/C++ 컴파일러는 구조체 멤버에 대한 접근 속도를 빠르게 하려고 메모리를 약간 낭비하는 방식을 취한다
/*
   ----  a  ---- b -       ------ c -----d- 
   l           l   l       l           l  l
   V           V   V       V           V  V
   ----------------------------------------------------
   l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l
   ----------------------------------------------------
 */

// 양쪽 프로그램이 동일한 구조체 멤버 맞춤을 사용한다면 이와 같이 메시지를 전송해도 문제가 되지 않는다
// 만약 정확히 10바이트를 보내고자 한다면 다음과 같이 #pragma pack 지시자를 사용하면 된다
/*struct MyMessage
{
	int a;  // 4바이트
	int b;  // 1바이트
	int c;	// 4바이트
	char d;	// 1바이트
}
#pragam pack() // 구조체 멤버 맞춤을 기본값으로 환원
MyMessage msg;
...
send(sock, (char*)&msg, sizeof(msg), 0);*/

// 이때 변수 msg의 메모리 구조는 다음과 같다

 /*
 ----  a  ---- b ----- c ----  d -
 l           l   l           l   l
 V           V   V           V   V
 ---------------------------------
 l  l  l  l  l  l  l  l  l  l  l l
 ---------------------------------
 */


// #pragma pack 지시자는 개별 구조체 단위로 멤버 맞춤을 변경할 때 사용한다
// 일반적으로 권장하지는 않지만 프로젝트 전체 혹은 파일 단위로 구조체 멤버 맞춤을 변경할 수 있다
// (프로젝트 속성 -> C/C++ -> 코드 생성 -> 구조체 멤버 맟춤)

// 데이터 전송 후 종료
// 데이터 전송 후 종료 방식은 일종의 가변 길이 데이터 전송 방식이다
// EOR로 특별한 데이터 패턴을 사용하는 대신 연결 종료를 사용한다


