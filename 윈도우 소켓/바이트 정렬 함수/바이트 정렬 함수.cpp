#pragma comment(lib,"ws2_32")
#include <winsock2.h>
#include <stdio.h>

// 바이트 정렬은 메모리에 데이터를 저장할 때 바이트 순서를 나타내는 용어이다
// 빅 엔디안 과 리틀 엔디안 방식이 있다

// 빅 엔디안 - 최상위 바이트(MSB, Most Significant Byte) 부터 차례로 저장하는 방식
// 리틀 엔디안 - 최하위 바이트(LSB, Least Significant Byte) 부터 차례로 저장하는 방식
// 시스템에서 사용하는 바이트 정렬 방식은 CPU와 운영체제에 따라 다르다

// 예) 빅 엔디안 - 0x12 0x34 0x56 0x78
//	 리틀 엔디안 - 0x78 0x56 0x34 0x12

// 파일에 데이터를 저장하고 읽어오는 경우나 네트워크를 통해 데이터를 송신하고 수신하는 경우에는 바이트 정렬 방식에 유의해야 한다
// 네트워크 통신에서 바이트 정렬 방식을 고려해야 하는 경우는 2가지가 있는데

// 1.IP주소, 포트 번호와 같이 프로토콜 구현을 위해 필요한 정보
// - 호스트와 라우터가 IP 주소의 바이트 정렬 방식을 약속하지 않으면 IP 주소 해석이 달라져 라우팅에 문제가 생길 수 있다
// - 두 호스트가 포트 번호의 바이트 정렬 방식을 약속하지 않으면 포트 번호 해석이 달라져 데이터가 잘못된 목적지 프로세스에 전달될 수 있다

// 이러한 문제는 시스템이 사용하는 바이트 정렬 방식이 통일되어 있지 않아서 발생한다
// 이를 해결하기 위해 IP주소와 포트 번호의 바이트 정렬 방식은 빅 엔디안으로 통일해 사용한다 (네트워크 용어로는 빅 엔디안을" 네트워크 바이트 정렬" 이라 부른다)

// 2 응용 프로그램이 주고받는 데이터
// - 두 호스트가 주고받는 데이터에 대해 바이트 정렬 방식을 약속하지 않으면 데이터 해석 문제가 발생할 수 있다
// - 이때도 상호 약속이 필요한데 대개는 네트워크 바이트 정렬(빅 엔디안) 방식을 사용한다
// - 클라이언트만 제작한다면 기존 서버가 정한 바이트 정렬 방식을 따르면 된다

// -----------------------------------------------------------------------------------------------------------------------

// 응용 프로그램이 바이트 정렬 방식을 편리하게 변환할 수 있도록 윈속 함수가 제공된다

// hton*() - 호스트 바이트 정렬로 저장된 값을 입력으로 받아서 네트워크 바이트 정렬로 변환한 값을 리턴한다
// ntoh*() - 네트워크 바이트 정렬로 저장된 값을 입력으로 받아서 호스트 바이트 정렬로 변환한 값을 리턴한다
// *s() 함수는 16비트 값을, *l() 함수는 32비트 값을 입력으로 받으므로 데이터 크기에 따라 적합한 버전을 선택해서 사용하면 된다

// u_short htons(u_short hostshort); // host to network
// u_long  htonl(u_long hostlong);
// u_short ntohs(u_short hostshort); // network to host
// u_long  ntohl(u_long netlong);

// 일방적으로 hton*() 함수는 응용 프로그램이 소켓 함수에 데이터를 넘겨주기 전에 호출하며
// ntoh*() 함수는 소켓 함수가 결과로 리턴한 데이터를 응용 프로그램이 출력 등의 목적으로 사용하기 전에 호출한다

// hton*() 함수 예)
// 응용 프로그램이 소켓 함수에 넘겨줄 데이터 -> hton*() -> 변환된 데이터(소켓 함수가 사용) -> 소켓 함수

// ntoh*() 함수 예)
// 변환된 데이터(응용 프로그램이 사용) -> ntoh*() -> 소켓 함수가 결과로 리턴한 데이터 -> 소켓 함수

// -------------------------------------------------------------------------------------------------------------------------

// 윈속 2.x 에서는 바이트 정렬을 위해 다음과 같은 확장 함수도 지원하다
// 첫 번째 인자로 소켓 디스크립터를 사용하고, 변환된 결과를 리턴 값이 아닌 세 번째 인자로 전달한다는 차이가 있다

// int WSAHtons(SOCKET s, u_short hostshrot, u_short* lpnetshrot);
// int WSAHtonl(SOCKET s, u_long hostlong, u_long* lpnetlong);

// int WSANtons(SOCKET s, u_short netshrot, u_short* lphostshort);
// int WSANtonl(SOCKET s, u_short netlong, u_short* lphostlong);

// SOCKADDR_IN / SOCKADDR_IN6 구조체의 바이트 정렬 방식

// SOCKADDR_IN{}                       SOCKADDR_IN6{}
// sin_family --> 네트워크 바이트 정렬  sin6_family   --> 네트워크 바이트 정렬
// sin_port   --> 호스트 바이트 정렬    sin6_port     --> 호스트 바이트 정렬
// sin_addr   --> 호스트 바이트 정렬    sin6_flowinfo --> 호스트 바이트 정렬
// sin_zero   --> 네트워크 바이트 정렬  sin6_addr     --> 호스트 바이트 정렬
//                                     sin6_scope_id --> 네트워크 바이트 정렬

int main(int argc, char* argv[])
{
	WSADATA wsa;

	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return 1;

	u_short x1 = 0x1234;
	u_long  y1 = 0x12345678;
	u_short x2;
	u_long  y2;

	// hton*() 함수를 사용해 바이트 정렬을 바꾼 후 
	// 다시 ntoh*() 함수를 사용해 원래 바이트 정렬로 되돌리는 것을 보여준다
	printf("[호스트 바이트 -> 네트워크 바이트]\n");
	printf("0x%x -> 0x%x\n", x1, x2 = htons(x1));
	printf("0x%x -> 0x%x\n", y1, y2 = htonl(y1));

	printf("\n[네트워크 바이트 -> 호스트 바이트]\n");
	printf("0x%x -> 0x%x\n", x2, ntohs(x2));
	printf("0x%x -> 0x%x\n", y2, ntohl(y2));

	// u_long 형을 입력으로 받는 함수에 u_short 형을 사용할 때 발생하는 문제점을 보여준다
	printf("\n[잘못된 사용 예]\n");
	printf("0x%x -> 0x%x\n", x1, htonl(x1));

	WSACleanup();

	return 0;
}